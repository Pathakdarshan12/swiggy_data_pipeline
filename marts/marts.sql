-- ============================================================================
-- MARTS
-- ============================================================================
-- Customer Analytics Views (1-4):
--   - MART_CUSTOMER_COHORT_ANALYSIS
--   - MART_CUSTOMER_ORDER_SUMMARY
--   - MART_CUSTOMER_RESTAURANT_PREFERENCES
--   - MART_CUSTOMER_TIME_PATTERNS
--
-- Delivery Analytics Views (5-8):
--   - MART_DELIVERY_AGENT_PERFORMANCE
--   - MART_DELIVERY_LOCATION_PERFORMANCE
--   - MART_DELIVERY_STATUS_TRANSITIONS
--   - MART_DELIVERY_TIME_ANALYSIS
--
-- Order Analytics Views (9-16):
--   - MART_ORDER_COHORT_ANALYSIS
--   - MART_ORDER_CUSTOMER_JOURNEY
--   - MART_ORDER_FULFILLMENT_ANALYSIS
--   - MART_ORDER_PAYMENT_ANALYSIS
--   - MART_ORDER_RESTAURANT_PERFORMANCE
--   - MART_ORDER_STATUS_ANALYSIS
--   - MART_ORDER_SUMMARY
--   - MART_ORDER_TIME_ANALYSIS
--
-- Restaurant Analytics Views (17-20):
--   - MART_CUISINE_PERFORMANCE
--   - MART_RESTAURANT_MENU_PERFORMANCE
--   - MART_RESTAURANT_PERFORMANCE
--   - MART_RESTAURANT_TIME_PERFORMANCE


USE WAREHOUSE ADHOC_WH;
USE DATABASE DATAVELOCITY;
USE SCHEMA ANALYTICS;

-- ============================================================================
-- 1. MART_CUSTOMER_COHORT_ANALYSIS
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_CUSTOMER_COHORT_ANALYSIS AS
WITH first_orders AS (
    SELECT
        CUSTOMER_ID,
        DATE_TRUNC('MONTH', MIN(ORDER_DATE)) AS COHORT_MONTH
    FROM GOLD.FACT_ORDER
    WHERE STATUS = 'ACTIVE'
    GROUP BY CUSTOMER_ID
),
cohort_data AS (
    SELECT
        f.COHORT_MONTH,
        DATE_TRUNC('MONTH', o.ORDER_DATE) AS ORDER_MONTH,
        DATEDIFF(MONTH, f.COHORT_MONTH, DATE_TRUNC('MONTH', o.ORDER_DATE)) AS MONTHS_SINCE_FIRST_ORDER,
        COUNT(DISTINCT o.CUSTOMER_ID) AS ACTIVE_CUSTOMERS,
        COUNT(DISTINCT o.ORDER_ID) AS TOTAL_ORDERS,
        SUM(o.TOTAL_AMOUNT) AS TOTAL_REVENUE
    FROM first_orders f
    INNER JOIN GOLD.FACT_ORDER o
        ON f.CUSTOMER_ID = o.CUSTOMER_ID
    WHERE o.STATUS = 'ACTIVE'
    GROUP BY
        f.COHORT_MONTH,
        ORDER_MONTH,
        MONTHS_SINCE_FIRST_ORDER
)
SELECT
    COHORT_MONTH,
    ORDER_MONTH,
    MONTHS_SINCE_FIRST_ORDER,
    ACTIVE_CUSTOMERS,
    TOTAL_ORDERS,
    TOTAL_REVENUE,
    ROUND(
        DIV0(ACTIVE_CUSTOMERS,
             FIRST_VALUE(ACTIVE_CUSTOMERS) OVER (
                 PARTITION BY COHORT_MONTH
                 ORDER BY MONTHS_SINCE_FIRST_ORDER
             )) * 100,
        2
    ) AS RETENTION_RATE,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM cohort_data;

-- ============================================================================
-- 2. MART_CUSTOMER_ORDER_SUMMARY
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_CUSTOMER_ORDER_SUMMARY AS
WITH customer_orders AS (
    SELECT
        c.CUSTOMER_ID,
        c.CUSTOMER_NAME,
        c.GENDER,
        c.DOB,
        DATEDIFF(YEAR, c.DOB, CURRENT_DATE()) AS CUSTOMER_AGE,
        c.LOGIN_BY_USING,
        c.PREFERENCES,
        o.ORDER_ID,
        o.ORDER_DATE,
        o.TOTAL_AMOUNT,
        o.PAYMENT_METHOD,
        o.STATUS AS CURRENT_STATUS
    FROM GOLD.DIM_CUSTOMER c
    LEFT JOIN GOLD.FACT_ORDER o
        ON c.CUSTOMER_ID = o.CUSTOMER_ID
        AND o.STATUS = 'ACTIVE'
    WHERE c.STATUS = 'ACTIVE'
),
customer_metrics AS (
    SELECT
        CUSTOMER_ID,
        CUSTOMER_NAME,
        GENDER,
        DOB,
        CUSTOMER_AGE,
        LOGIN_BY_USING,
        PREFERENCES,
        COUNT(DISTINCT ORDER_ID) AS TOTAL_ORDERS,
        SUM(TOTAL_AMOUNT) AS LIFETIME_VALUE,
        AVG(TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
        MIN(ORDER_DATE) AS FIRST_ORDER_DATE,
        MAX(ORDER_DATE) AS LAST_ORDER_DATE,
        DATEDIFF(DAY, MIN(ORDER_DATE), MAX(ORDER_DATE)) AS CUSTOMER_TENURE_DAYS,
        DATEDIFF(DAY, MAX(ORDER_DATE), CURRENT_DATE()) AS DAYS_SINCE_LAST_ORDER,
        COUNT(DISTINCT DATE_TRUNC('MONTH', ORDER_DATE)) AS ACTIVE_MONTHS,
        DIV0(COUNT(DISTINCT ORDER_ID),
             NULLIF(COUNT(DISTINCT DATE_TRUNC('MONTH', ORDER_DATE)), 0)) AS ORDERS_PER_ACTIVE_MONTH,
        MODE(PAYMENT_METHOD) AS PREFERRED_PAYMENT_METHOD,
        COUNT(DISTINCT PAYMENT_METHOD) AS PAYMENT_METHODS_USED,
        SUM(CASE WHEN CURRENT_STATUS = 'COMPLETED' THEN 1 ELSE 0 END) AS COMPLETED_ORDERS,
        SUM(CASE WHEN CURRENT_STATUS = 'CANCELLED' THEN 1 ELSE 0 END) AS CANCELLED_ORDERS,
        DIV0(SUM(CASE WHEN CURRENT_STATUS = 'CANCELLED' THEN 1 ELSE 0 END),
             COUNT(*)) * 100 AS CANCELLATION_RATE
    FROM customer_orders
    GROUP BY
        CUSTOMER_ID, CUSTOMER_NAME, GENDER, DOB, CUSTOMER_AGE,
        LOGIN_BY_USING, PREFERENCES
)
SELECT
    *,
    CASE
        WHEN TOTAL_ORDERS >= 20 THEN 'VIP'
        WHEN TOTAL_ORDERS >= 10 THEN 'LOYAL'
        WHEN TOTAL_ORDERS >= 5 THEN 'REGULAR'
        WHEN TOTAL_ORDERS >= 2 THEN 'REPEAT'
        ELSE 'NEW'
    END AS CUSTOMER_SEGMENT,
    CASE
        WHEN DAYS_SINCE_LAST_ORDER <= 30 THEN 'ACTIVE'
        WHEN DAYS_SINCE_LAST_ORDER <= 90 THEN 'AT_RISK'
        ELSE 'CHURNED'
    END AS CUSTOMER_STATUS,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM customer_metrics;

-- ============================================================================
-- 3. MART_CUSTOMER_RESTAURANT_PREFERENCES
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_CUSTOMER_RESTAURANT_PREFERENCES AS
SELECT
    c.CUSTOMER_ID,
    c.CUSTOMER_NAME,
    r.RESTAURANT_ID,
    r.RESTAURANT_NAME,
    r.CUISINE_TYPE,
    l.CITY,
    l.STATE,
    COUNT(DISTINCT o.ORDER_ID) AS ORDERS_FROM_RESTAURANT,
    SUM(o.TOTAL_AMOUNT) AS TOTAL_SPENT,
    AVG(o.TOTAL_AMOUNT) AS AVG_SPEND_PER_ORDER,
    MAX(o.ORDER_DATE) AS LAST_ORDER_DATE,
    ROW_NUMBER() OVER (
        PARTITION BY c.CUSTOMER_ID
        ORDER BY COUNT(DISTINCT o.ORDER_ID) DESC
    ) AS RESTAURANT_PREFERENCE_RANK,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.DIM_CUSTOMER c
INNER JOIN GOLD.FACT_ORDER o
    ON c.CUSTOMER_ID = o.CUSTOMER_ID
    AND o.STATUS = 'ACTIVE'
INNER JOIN GOLD.DIM_RESTAURANT r
    ON o.RESTAURANT_ID = r.RESTAURANT_ID
    AND r.STATUS = 'ACTIVE'
LEFT JOIN GOLD.DIM_LOCATION l
    ON r.LOCATION_ID = l.LOCATION_ID
WHERE c.STATUS = 'ACTIVE'
GROUP BY
    c.CUSTOMER_ID, c.CUSTOMER_NAME, r.RESTAURANT_ID, r.RESTAURANT_NAME,
    r.CUISINE_TYPE, l.CITY, l.STATE
QUALIFY RESTAURANT_PREFERENCE_RANK <= 10;

-- ============================================================================
-- 4. MART_CUSTOMER_TIME_PATTERNS
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_CUSTOMER_TIME_PATTERNS AS
SELECT
    o.CUSTOMER_ID,
    c.CUSTOMER_NAME,
    d.DAY_NAME,
    d.DAY_OF_WEEK,
    COUNT(DISTINCT o.ORDER_ID) AS ORDERS_BY_DAY,
    SUM(o.TOTAL_AMOUNT) AS REVENUE_BY_DAY,
    HOUR(o.ORDER_DATE) AS ORDER_HOUR,
    CASE
        WHEN HOUR(o.ORDER_DATE) BETWEEN 6 AND 11 THEN 'MORNING'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 12 AND 16 THEN 'AFTERNOON'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 17 AND 21 THEN 'EVENING'
        ELSE 'NIGHT'
    END AS TIME_OF_DAY,
    CASE
        WHEN d.DAY_OF_WEEK IN (6, 7) THEN 'WEEKEND'
        ELSE 'WEEKDAY'
    END AS DAY_TYPE,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.FACT_ORDER o
INNER JOIN GOLD.DIM_CUSTOMER c
    ON o.CUSTOMER_ID = c.CUSTOMER_ID
    AND c.STATUS = 'ACTIVE'
LEFT JOIN GOLD.DIM_DATE d
    ON DATE(o.ORDER_DATE) = d.CALENDAR_DATE
WHERE o.STATUS = 'ACTIVE'
GROUP BY
    o.CUSTOMER_ID, c.CUSTOMER_NAME, d.DAY_NAME, d.DAY_OF_WEEK,
    ORDER_HOUR, TIME_OF_DAY, DAY_TYPE;

-- ============================================================================
-- 5. MART_DELIVERY_AGENT_PERFORMANCE
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_DELIVERY_AGENT_PERFORMANCE AS
SELECT
    da.DELIVERY_AGENT_ID,
    da.DELIVERY_AGENT_NAME,
    da.PHONE,
    da.VEHICLE_TYPE,
    da.GENDER,
    da.RATING AS CURRENT_RATING,
    l.CITY,
    l.STATE,
    COUNT(DISTINCT fd.DELIVERY_ID) AS TOTAL_DELIVERIES,
    SUM(CASE WHEN fd.STATUS = 'DELIVERED' THEN 1 ELSE 0 END) AS SUCCESSFUL_DELIVERIES,
    SUM(CASE WHEN fd.STATUS = 'FAILED' THEN 1 ELSE 0 END) AS FAILED_DELIVERIES,
    SUM(CASE WHEN fd.STATUS = 'CANCELLED' THEN 1 ELSE 0 END) AS CANCELLED_DELIVERIES,
    DIV0(SUM(CASE WHEN fd.STATUS = 'DELIVERED' THEN 1 ELSE 0 END),
         COUNT(*)) * 100 AS SUCCESS_RATE,
    AVG(TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER)) AS AVG_ESTIMATED_TIME_MINS,
    MIN(fd.DELIVERY_DATE) AS FIRST_DELIVERY_DATE,
    MAX(fd.DELIVERY_DATE) AS LAST_DELIVERY_DATE,
    DATEDIFF(DAY, MIN(fd.DELIVERY_DATE), MAX(fd.DELIVERY_DATE)) AS TENURE_DAYS,
    DIV0(COUNT(DISTINCT fd.DELIVERY_ID),
         NULLIF(COUNT(DISTINCT DATE(fd.DELIVERY_DATE)), 0)) AS AVG_DELIVERIES_PER_DAY,
    CASE
        WHEN DIV0(SUM(CASE WHEN fd.STATUS = 'DELIVERED' THEN 1 ELSE 0 END), COUNT(*)) * 100 >= 95
            AND COUNT(DISTINCT fd.DELIVERY_ID) >= 100 THEN 'EXCELLENT'
        WHEN DIV0(SUM(CASE WHEN fd.STATUS = 'DELIVERED' THEN 1 ELSE 0 END), COUNT(*)) * 100 >= 90 THEN 'GOOD'
        WHEN DIV0(SUM(CASE WHEN fd.STATUS = 'DELIVERED' THEN 1 ELSE 0 END), COUNT(*)) * 100 >= 80 THEN 'AVERAGE'
        ELSE 'NEEDS_IMPROVEMENT'
    END AS PERFORMANCE_TIER,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.DIM_DELIVERY_AGENT da
LEFT JOIN GOLD.FACT_DELIVERY fd
    ON da.DELIVERY_AGENT_ID = fd.DELIVERY_AGENT_ID
    AND fd.STATUS = 'ACTIVE'
LEFT JOIN GOLD.DIM_LOCATION l
    ON da.LOCATION_ID = l.LOCATION_ID
WHERE da.STATUS = 'ACTIVE'
GROUP BY
    da.DELIVERY_AGENT_ID, da.DELIVERY_AGENT_NAME, da.PHONE,
    da.VEHICLE_TYPE, da.GENDER, da.RATING, l.CITY, l.STATE;

-- ============================================================================
-- 6. MART_DELIVERY_LOCATION_PERFORMANCE
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_DELIVERY_LOCATION_PERFORMANCE AS
SELECT
    l.CITY,
    l.STATE,
    l.CITY_TIER,
    ca.LOCALITY,
    COUNT(DISTINCT fd.DELIVERY_ID) AS TOTAL_DELIVERIES,
    COUNT(DISTINCT fd.DELIVERY_AGENT_ID) AS UNIQUE_AGENTS,
    SUM(CASE WHEN fd.STATUS = 'DELIVERED' THEN 1 ELSE 0 END) AS SUCCESSFUL_DELIVERIES,
    DIV0(SUM(CASE WHEN fd.STATUS = 'DELIVERED' THEN 1 ELSE 0 END),
         COUNT(*)) * 100 AS SUCCESS_RATE,
    AVG(TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER)) AS AVG_ESTIMATED_TIME,
    AVG(DATEDIFF(MINUTE, fd.CREATED_AT, fd.UPDATED_AT)) AS AVG_ACTUAL_TIME,
    MODE(HOUR(fd.DELIVERY_DATE)) AS PEAK_DELIVERY_HOUR,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.FACT_DELIVERY fd
LEFT JOIN GOLD.DIM_CUSTOMER_ADDRESS ca
    ON fd.CUSTOMER_ADDRESS_ID = ca.CUSTOMER_ADDRESS_ID
LEFT JOIN GOLD.DIM_LOCATION l
    ON ca.CITY = l.CITY
WHERE fd.STATUS = 'ACTIVE'
GROUP BY l.CITY, l.STATE, l.CITY_TIER, ca.LOCALITY;

-- ============================================================================
-- 7. MART_DELIVERY_STATUS_TRANSITIONS
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_DELIVERY_STATUS_TRANSITIONS AS
SELECT
    fdsh.DELIVERY_ID,
    fdsh.OLD_STATUS,
    fdsh.NEW_STATUS,
    fdsh.STATUS_CHANGED_AT,
    LAG(fdsh.STATUS_CHANGED_AT) OVER (
        PARTITION BY fdsh.DELIVERY_ID
        ORDER BY fdsh.STATUS_CHANGED_AT
    ) AS PREVIOUS_STATUS_TIME,
    DATEDIFF(
        MINUTE,
        LAG(fdsh.STATUS_CHANGED_AT) OVER (
            PARTITION BY fdsh.DELIVERY_ID
            ORDER BY fdsh.STATUS_CHANGED_AT
        ),
        fdsh.STATUS_CHANGED_AT
    ) AS MINS_IN_PREVIOUS_STATUS,
    ROW_NUMBER() OVER (
        PARTITION BY fdsh.DELIVERY_ID
        ORDER BY fdsh.STATUS_CHANGED_AT
    ) AS STATUS_SEQUENCE,
    da.DELIVERY_AGENT_NAME,
    da.VEHICLE_TYPE,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.FACT_DELIVERY_STATUS_HISTORY fdsh
LEFT JOIN GOLD.FACT_DELIVERY fd
    ON fdsh.DELIVERY_ID = fd.DELIVERY_ID
LEFT JOIN GOLD.DIM_DELIVERY_AGENT da
    ON fd.DELIVERY_AGENT_ID = da.DELIVERY_AGENT_ID;

-- ============================================================================
-- 8. MART_DELIVERY_TIME_ANALYSIS
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_DELIVERY_TIME_ANALYSIS AS
SELECT
    fd.DELIVERY_ID,
    fd.ORDER_ID,
    fd.DELIVERY_AGENT_ID,
    da.DELIVERY_AGENT_NAME,
    da.VEHICLE_TYPE,
    l.CITY,
    l.STATE,
    ca.LOCALITY AS DELIVERY_LOCALITY,
    fd.STATUS AS CURRENT_STATUS,
    fd.STATUS AS INITIAL_STATUS,
    fd.DELIVERY_DATE,
    fd.UPDATED_AT AS STATUS_UPDATED_AT,
    TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER) AS ESTIMATED_TIME_MINS,
    DATEDIFF(MINUTE, fd.CREATED_AT, fd.UPDATED_AT) AS ACTUAL_DELIVERY_TIME_MINS,
    DATEDIFF(MINUTE, fd.CREATED_AT, fd.UPDATED_AT) -
        TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER) AS TIME_VARIANCE_MINS,
    CASE
        WHEN DATEDIFF(MINUTE, fd.CREATED_AT, fd.UPDATED_AT) <=
             TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER) THEN 'ON_TIME'
        WHEN DATEDIFF(MINUTE, fd.CREATED_AT, fd.UPDATED_AT) <=
             TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER) + 10 THEN 'SLIGHTLY_DELAYED'
        ELSE 'DELAYED'
    END AS DELIVERY_TIMELINESS,
    d.DAY_NAME,
    d.DAY_OF_WEEK,
    HOUR(fd.DELIVERY_DATE) AS DELIVERY_HOUR,
    CASE
        WHEN HOUR(fd.DELIVERY_DATE) BETWEEN 6 AND 11 THEN 'MORNING'
        WHEN HOUR(fd.DELIVERY_DATE) BETWEEN 12 AND 16 THEN 'AFTERNOON'
        WHEN HOUR(fd.DELIVERY_DATE) BETWEEN 17 AND 21 THEN 'EVENING'
        ELSE 'NIGHT'
    END AS TIME_OF_DAY,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.FACT_DELIVERY fd
LEFT JOIN GOLD.DIM_DELIVERY_AGENT da
    ON fd.DELIVERY_AGENT_ID = da.DELIVERY_AGENT_ID
LEFT JOIN GOLD.DIM_CUSTOMER_ADDRESS ca
    ON fd.CUSTOMER_ADDRESS_ID = ca.CUSTOMER_ADDRESS_ID
LEFT JOIN GOLD.DIM_LOCATION l
    ON ca.CITY = l.CITY
LEFT JOIN GOLD.DIM_DATE d
    ON DATE(fd.DELIVERY_DATE) = d.CALENDAR_DATE
WHERE fd.STATUS IN ('DELIVERED', 'FAILED');

-- ============================================================================
-- 9. MART_ORDER_COHORT_ANALYSIS
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_ORDER_COHORT_ANALYSIS AS
WITH first_orders AS (
    SELECT
        CUSTOMER_ID,
        MIN(ORDER_DATE) AS FIRST_ORDER_DATE,
        DATE_TRUNC('MONTH', MIN(ORDER_DATE)) AS COHORT_MONTH,
        DATE_TRUNC('WEEK', MIN(ORDER_DATE)) AS COHORT_WEEK,
        MIN(RESTAURANT_ID) AS FIRST_RESTAURANT_ID,
        MIN(TOTAL_AMOUNT) AS FIRST_ORDER_AMOUNT
    FROM GOLD.FACT_ORDER
    WHERE STATUS = 'ACTIVE'
    GROUP BY CUSTOMER_ID
),
cohort_orders AS (
    SELECT
        f.CUSTOMER_ID,
        f.COHORT_MONTH,
        f.COHORT_WEEK,
        f.FIRST_ORDER_DATE,
        f.FIRST_RESTAURANT_ID,
        f.FIRST_ORDER_AMOUNT,
        o.ORDER_ID,
        o.ORDER_DATE,
        o.TOTAL_AMOUNT,
        o.RESTAURANT_ID,
        DATE_TRUNC('MONTH', o.ORDER_DATE) AS ORDER_MONTH,
        DATEDIFF(MONTH, f.COHORT_MONTH, DATE_TRUNC('MONTH', o.ORDER_DATE)) AS MONTHS_SINCE_FIRST_ORDER,
        DATEDIFF(DAY, f.FIRST_ORDER_DATE, o.ORDER_DATE) AS DAYS_SINCE_FIRST_ORDER,
        ROW_NUMBER() OVER (PARTITION BY f.CUSTOMER_ID ORDER BY o.ORDER_DATE) AS ORDER_NUMBER
    FROM first_orders f
    INNER JOIN GOLD.FACT_ORDER o
        ON f.CUSTOMER_ID = o.CUSTOMER_ID
        AND o.STATUS = 'ACTIVE'
)
SELECT
    co.COHORT_MONTH,
    co.ORDER_MONTH,
    co.MONTHS_SINCE_FIRST_ORDER,
    COUNT(DISTINCT CASE WHEN co.ORDER_NUMBER = 1 THEN co.CUSTOMER_ID END) AS COHORT_SIZE,
    COUNT(DISTINCT co.CUSTOMER_ID) AS ACTIVE_CUSTOMERS,
    COUNT(DISTINCT co.ORDER_ID) AS TOTAL_ORDERS,
    SUM(co.TOTAL_AMOUNT) AS TOTAL_REVENUE,
    DIV0(
        COUNT(DISTINCT co.CUSTOMER_ID),
        COUNT(DISTINCT CASE WHEN co.ORDER_NUMBER = 1 THEN co.CUSTOMER_ID END)
    ) * 100 AS RETENTION_RATE,
    AVG(co.TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    DIV0(COUNT(DISTINCT co.ORDER_ID), COUNT(DISTINCT co.CUSTOMER_ID)) AS ORDERS_PER_CUSTOMER,
    DIV0(SUM(co.TOTAL_AMOUNT), COUNT(DISTINCT co.CUSTOMER_ID)) AS REVENUE_PER_CUSTOMER,
    AVG(co.FIRST_ORDER_AMOUNT) AS AVG_FIRST_ORDER_AMOUNT,
    SUM(CASE WHEN co.RESTAURANT_ID = co.FIRST_RESTAURANT_ID THEN 1 ELSE 0 END) AS ORDERS_FROM_FIRST_RESTAURANT,
    DIV0(
        SUM(CASE WHEN co.RESTAURANT_ID = co.FIRST_RESTAURANT_ID THEN 1 ELSE 0 END),
        COUNT(DISTINCT co.ORDER_ID)
    ) * 100 AS FIRST_RESTAURANT_LOYALTY_RATE,
    SUM(SUM(co.TOTAL_AMOUNT)) OVER (
        PARTITION BY co.COHORT_MONTH
        ORDER BY co.MONTHS_SINCE_FIRST_ORDER
    ) AS CUMULATIVE_COHORT_REVENUE,
    AVG(co.DAYS_SINCE_FIRST_ORDER) AS AVG_DAYS_FROM_FIRST_ORDER,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM cohort_orders co
GROUP BY
    co.COHORT_MONTH,
    co.ORDER_MONTH,
    co.MONTHS_SINCE_FIRST_ORDER;

-- ============================================================================
-- 10. MART_ORDER_CUSTOMER_JOURNEY
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_ORDER_CUSTOMER_JOURNEY AS
WITH customer_order_sequence AS (
    SELECT
        o.ORDER_ID,
        o.CUSTOMER_ID,
        o.ORDER_DATE,
        o.TOTAL_AMOUNT,
        o.RESTAURANT_ID,
        o.PAYMENT_METHOD,
        o.STATUS AS CURRENT_STATUS,
        ROW_NUMBER() OVER (
            PARTITION BY o.CUSTOMER_ID
            ORDER BY o.ORDER_DATE
        ) AS ORDER_SEQUENCE_NUMBER,
        LAG(o.ORDER_DATE) OVER (
            PARTITION BY o.CUSTOMER_ID
            ORDER BY o.ORDER_DATE
        ) AS PREVIOUS_ORDER_DATE,
        LAG(o.RESTAURANT_ID) OVER (
            PARTITION BY o.CUSTOMER_ID
            ORDER BY o.ORDER_DATE
        ) AS PREVIOUS_RESTAURANT_ID,
        LAG(o.TOTAL_AMOUNT) OVER (
            PARTITION BY o.CUSTOMER_ID
            ORDER BY o.ORDER_DATE
        ) AS PREVIOUS_ORDER_AMOUNT,
        LEAD(o.ORDER_DATE) OVER (
            PARTITION BY o.CUSTOMER_ID
            ORDER BY o.ORDER_DATE
        ) AS NEXT_ORDER_DATE
    FROM GOLD.FACT_ORDER o
    WHERE o.STATUS = 'ACTIVE'
)
SELECT
    cos.ORDER_ID,
    cos.CUSTOMER_ID,
    c.CUSTOMER_NAME,
    c.GENDER,
    DATEDIFF(YEAR, c.DOB, cos.ORDER_DATE) AS CUSTOMER_AGE_AT_ORDER,
    cos.ORDER_DATE,
    cos.TOTAL_AMOUNT,
    cos.CURRENT_STATUS,
    cos.RESTAURANT_ID,
    r.RESTAURANT_NAME,
    r.CUISINE_TYPE,
    l.CITY,
    l.STATE,
    cos.ORDER_SEQUENCE_NUMBER,
    CASE
        WHEN cos.ORDER_SEQUENCE_NUMBER = 1 THEN 'FIRST_ORDER'
        WHEN cos.ORDER_SEQUENCE_NUMBER = 2 THEN 'SECOND_ORDER'
        WHEN cos.ORDER_SEQUENCE_NUMBER <= 5 THEN 'EARLY_ORDERS'
        WHEN cos.ORDER_SEQUENCE_NUMBER <= 10 THEN 'REGULAR_CUSTOMER'
        ELSE 'LOYAL_CUSTOMER'
    END AS CUSTOMER_JOURNEY_STAGE,
    DATEDIFF(DAY, cos.PREVIOUS_ORDER_DATE, cos.ORDER_DATE) AS DAYS_SINCE_LAST_ORDER,
    CASE
        WHEN DATEDIFF(DAY, cos.PREVIOUS_ORDER_DATE, cos.ORDER_DATE) <= 1 THEN 'SAME_DAY'
        WHEN DATEDIFF(DAY, cos.PREVIOUS_ORDER_DATE, cos.ORDER_DATE) <= 7 THEN 'WITHIN_WEEK'
        WHEN DATEDIFF(DAY, cos.PREVIOUS_ORDER_DATE, cos.ORDER_DATE) <= 30 THEN 'WITHIN_MONTH'
        WHEN DATEDIFF(DAY, cos.PREVIOUS_ORDER_DATE, cos.ORDER_DATE) <= 90 THEN 'WITHIN_QUARTER'
        ELSE 'REACTIVATED'
    END AS ORDER_FREQUENCY_TYPE,
    CASE
        WHEN cos.RESTAURANT_ID = cos.PREVIOUS_RESTAURANT_ID THEN 1
        ELSE 0
    END AS IS_REPEAT_RESTAURANT,
    COUNT(cos.RESTAURANT_ID) OVER (
        PARTITION BY cos.CUSTOMER_ID
        ORDER BY cos.ORDER_DATE
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS RESTAURANTS_TRIED_TO_DATE,
    cos.PREVIOUS_ORDER_AMOUNT,
    cos.TOTAL_AMOUNT - COALESCE(cos.PREVIOUS_ORDER_AMOUNT, 0) AS ORDER_AMOUNT_CHANGE,
    CASE
        WHEN cos.TOTAL_AMOUNT > COALESCE(cos.PREVIOUS_ORDER_AMOUNT, 0) THEN 'INCREASED'
        WHEN cos.TOTAL_AMOUNT < COALESCE(cos.PREVIOUS_ORDER_AMOUNT, 0) THEN 'DECREASED'
        WHEN cos.PREVIOUS_ORDER_AMOUNT IS NULL THEN 'FIRST_ORDER'
        ELSE 'SAME'
    END AS SPENDING_TREND,
    SUM(cos.TOTAL_AMOUNT) OVER (
        PARTITION BY cos.CUSTOMER_ID
        ORDER BY cos.ORDER_DATE
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS CUMULATIVE_SPEND,
    AVG(cos.TOTAL_AMOUNT) OVER (
        PARTITION BY cos.CUSTOMER_ID
        ORDER BY cos.ORDER_DATE
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS AVG_ORDER_VALUE_TO_DATE,
    DATEDIFF(DAY, cos.ORDER_DATE, cos.NEXT_ORDER_DATE) AS DAYS_UNTIL_NEXT_ORDER,
    CASE
        WHEN cos.NEXT_ORDER_DATE IS NULL
            AND DATEDIFF(DAY, cos.ORDER_DATE, CURRENT_DATE()) > 90
        THEN 'HIGH_CHURN_RISK'
        WHEN cos.NEXT_ORDER_DATE IS NULL
            AND DATEDIFF(DAY, cos.ORDER_DATE, CURRENT_DATE()) > 30
        THEN 'MEDIUM_CHURN_RISK'
        WHEN cos.NEXT_ORDER_DATE IS NULL THEN 'LOW_CHURN_RISK'
        ELSE 'RETURNED'
    END AS CHURN_RISK_LEVEL,
    cos.PAYMENT_METHOD,
    COUNT(cos.PAYMENT_METHOD) OVER (
        PARTITION BY cos.CUSTOMER_ID
        ORDER BY cos.ORDER_DATE
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS PAYMENT_METHODS_USED_TO_DATE,
    HOUR(cos.ORDER_DATE) AS ORDER_HOUR,
    CASE
        WHEN HOUR(cos.ORDER_DATE) BETWEEN 6 AND 11 THEN 'MORNING'
        WHEN HOUR(cos.ORDER_DATE) BETWEEN 12 AND 16 THEN 'AFTERNOON'
        WHEN HOUR(cos.ORDER_DATE) BETWEEN 17 AND 21 THEN 'EVENING'
        ELSE 'NIGHT'
    END AS TIME_OF_DAY,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM customer_order_sequence cos
LEFT JOIN GOLD.DIM_CUSTOMER c
    ON cos.CUSTOMER_ID = c.CUSTOMER_ID
LEFT JOIN GOLD.DIM_RESTAURANT r
    ON cos.RESTAURANT_ID = r.RESTAURANT_ID
LEFT JOIN GOLD.DIM_LOCATION l
    ON r.LOCATION_ID = l.LOCATION_ID;

-- ============================================================================
-- 11. MART_ORDER_FULFILLMENT_ANALYSIS
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_ORDER_FULFILLMENT_ANALYSIS AS
SELECT
    o.ORDER_ID,
    o.ORDER_DATE,
    o.CUSTOMER_ID,
    c.CUSTOMER_NAME,
    o.RESTAURANT_ID,
    r.RESTAURANT_NAME,
    r.CUISINE_TYPE,
    o.TOTAL_AMOUNT,
    o.STATUS AS ORDER_STATUS,
    fd.DELIVERY_ID,
    fd.DELIVERY_AGENT_ID,
    da.DELIVERY_AGENT_NAME,
    da.VEHICLE_TYPE,
    da.RATING AS AGENT_RATING,
    fd.DELIVERY_DATE,
    fd.STATUS AS DELIVERY_STATUS,
    ca.LOCALITY AS DELIVERY_LOCALITY,
    ca.CITY AS DELIVERY_CITY,
    ca.ZIPCODE AS DELIVERY_ZIPCODE,
    ca.ADDRESS_TYPE,
    r.LOCALITY AS RESTAURANT_LOCALITY,
    l.CITY AS RESTAURANT_CITY,
    TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER) AS ESTIMATED_DELIVERY_TIME_MINS,
    DATEDIFF(MINUTE, o.ORDER_DATE, fd.DELIVERY_DATE) AS ACTUAL_DELIVERY_TIME_MINS,
    DATEDIFF(MINUTE, o.CREATED_AT, o.UPDATED_AT) AS ORDER_PROCESSING_TIME_MINS,
    DATEDIFF(MINUTE, fd.CREATED_AT, fd.UPDATED_AT) AS DELIVERY_PROCESSING_TIME_MINS,
    DATEDIFF(MINUTE, o.ORDER_DATE, fd.DELIVERY_DATE) -
        TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER) AS DELIVERY_TIME_VARIANCE_MINS,
    CASE
        WHEN DATEDIFF(MINUTE, o.ORDER_DATE, fd.DELIVERY_DATE) <=
            TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER)
        THEN 'ON_TIME'
        WHEN DATEDIFF(MINUTE, o.ORDER_DATE, fd.DELIVERY_DATE) <=
            TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER) + 10
        THEN 'SLIGHTLY_DELAYED'
        WHEN DATEDIFF(MINUTE, o.ORDER_DATE, fd.DELIVERY_DATE) <=
            TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER) + 20
        THEN 'DELAYED'
        ELSE 'SEVERELY_DELAYED'
    END AS DELIVERY_TIMELINESS,
    CASE
        WHEN DATEDIFF(MINUTE, o.ORDER_DATE, fd.DELIVERY_DATE) <= 30 THEN 'FAST'
        WHEN DATEDIFF(MINUTE, o.ORDER_DATE, fd.DELIVERY_DATE) <= 45 THEN 'NORMAL'
        WHEN DATEDIFF(MINUTE, o.ORDER_DATE, fd.DELIVERY_DATE) <= 60 THEN 'SLOW'
        ELSE 'VERY_SLOW'
    END AS DELIVERY_SPEED,
    CASE
        WHEN ca.LOCALITY = r.LOCALITY THEN 'SAME_LOCALITY'
        WHEN ca.CITY = l.CITY THEN 'SAME_CITY'
        ELSE 'DIFFERENT_CITY'
    END AS DELIVERY_DISTANCE_CATEGORY,
    CASE
        WHEN o.STATUS = 'COMPLETED'
            AND fd.STATUS = 'DELIVERED'
        THEN 1
        ELSE 0
    END AS IS_SUCCESSFULLY_FULFILLED,
    CASE
        WHEN o.STATUS = 'CANCELLED'
            OR fd.STATUS = 'FAILED'
        THEN 1
        ELSE 0
    END AS IS_FAILED_FULFILLMENT,
    HOUR(o.ORDER_DATE) AS ORDER_HOUR,
    CASE
        WHEN HOUR(o.ORDER_DATE) BETWEEN 6 AND 11 THEN 'MORNING'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 12 AND 16 THEN 'AFTERNOON'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 17 AND 21 THEN 'EVENING'
        ELSE 'NIGHT'
    END AS TIME_OF_DAY,
    d.DAY_NAME,
    CASE
        WHEN d.DAY_OF_WEEK IN (6, 7) THEN 'WEEKEND'
        ELSE 'WEEKDAY'
    END AS DAY_TYPE,
    COUNT(DISTINCT fd.DELIVERY_ID) OVER (
        PARTITION BY fd.DELIVERY_AGENT_ID, DATE(fd.DELIVERY_DATE)
    ) AS AGENT_DELIVERIES_SAME_DAY,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.FACT_ORDER o
LEFT JOIN GOLD.DIM_CUSTOMER c
    ON o.CUSTOMER_ID = c.CUSTOMER_ID
LEFT JOIN GOLD.DIM_RESTAURANT r
    ON o.RESTAURANT_ID = r.RESTAURANT_ID
LEFT JOIN GOLD.DIM_LOCATION l
    ON r.LOCATION_ID = l.LOCATION_ID
LEFT JOIN GOLD.FACT_DELIVERY fd
    ON o.ORDER_ID = fd.ORDER_ID
LEFT JOIN GOLD.DIM_DELIVERY_AGENT da
    ON fd.DELIVERY_AGENT_ID = da.DELIVERY_AGENT_ID
LEFT JOIN GOLD.DIM_CUSTOMER_ADDRESS ca
    ON fd.CUSTOMER_ADDRESS_ID = ca.CUSTOMER_ADDRESS_ID
LEFT JOIN GOLD.DIM_DATE d
    ON DATE(o.ORDER_DATE) = d.CALENDAR_DATE;

-- ============================================================================
-- 12. MART_ORDER_PAYMENT_ANALYSIS
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_ORDER_PAYMENT_ANALYSIS AS
SELECT
    o.ORDER_ID,
    o.ORDER_DATE,
    DATE(o.ORDER_DATE) AS ORDER_DATE_KEY,
    o.CUSTOMER_ID,
    c.CUSTOMER_NAME,
    o.RESTAURANT_ID,
    r.RESTAURANT_NAME,
    o.TOTAL_AMOUNT,
    o.PAYMENT_METHOD,
    o.STATUS AS CURRENT_STATUS,
    l.CITY,
    l.STATE,
    l.CITY_TIER,
    d.YEAR,
    d.MONTH,
    d.DAY_OF_WEEK,
    CASE
        WHEN d.DAY_OF_WEEK IN (6, 7) THEN 'WEEKEND'
        ELSE 'WEEKDAY'
    END AS DAY_TYPE,
    HOUR(o.ORDER_DATE) AS ORDER_HOUR,
    CASE
        WHEN o.PAYMENT_METHOD IN ('CARD', 'CREDIT_CARD', 'DEBIT_CARD') THEN 'CARD'
        WHEN o.PAYMENT_METHOD IN ('UPI', 'GPAY', 'PHONEPE', 'PAYTM') THEN 'UPI'
        WHEN o.PAYMENT_METHOD = 'CASH' THEN 'CASH'
        WHEN o.PAYMENT_METHOD = 'WALLET' THEN 'WALLET'
        WHEN o.PAYMENT_METHOD = 'NET_BANKING' THEN 'NET_BANKING'
        ELSE 'OTHER'
    END AS PAYMENT_CATEGORY,
    CASE
        WHEN o.TOTAL_AMOUNT < 200 THEN 'LOW_VALUE'
        WHEN o.TOTAL_AMOUNT < 500 THEN 'MEDIUM_VALUE'
        WHEN o.TOTAL_AMOUNT < 1000 THEN 'HIGH_VALUE'
        ELSE 'PREMIUM'
    END AS ORDER_VALUE_SEGMENT,
    COUNT(o.PAYMENT_METHOD) OVER (
        PARTITION BY o.CUSTOMER_ID
        ORDER BY o.ORDER_DATE
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS PAYMENT_METHODS_USED_TO_DATE,
    ROW_NUMBER() OVER (
        PARTITION BY o.CUSTOMER_ID, o.PAYMENT_METHOD
        ORDER BY o.ORDER_DATE
    ) AS PAYMENT_METHOD_USE_COUNT,
    CASE
        WHEN ROW_NUMBER() OVER (
            PARTITION BY o.CUSTOMER_ID, o.PAYMENT_METHOD
            ORDER BY o.ORDER_DATE
        ) = 1 THEN 1
        ELSE 0
    END AS IS_FIRST_USE_OF_PAYMENT_METHOD,
    COUNT(DISTINCT o.PAYMENT_METHOD) OVER (
        PARTITION BY o.RESTAURANT_ID
    ) AS RESTAURANT_PAYMENT_METHODS_ACCEPTED,
    CASE
        WHEN o.STATUS = 'COMPLETED' THEN 1
        ELSE 0
    END AS PAYMENT_SUCCESS,
    CASE
        WHEN o.STATUS = 'CANCELLED'
            AND o.PAYMENT_METHOD IN ('CARD', 'UPI', 'NET_BANKING')
        THEN 1
        ELSE 0
    END AS POTENTIAL_PAYMENT_FAILURE,
    AVG(o.TOTAL_AMOUNT) OVER (
        PARTITION BY o.CUSTOMER_ID, o.PAYMENT_METHOD
    ) AS CUSTOMER_AVG_ORDER_VALUE_BY_PAYMENT,
    AVG(o.TOTAL_AMOUNT) OVER (
        PARTITION BY o.RESTAURANT_ID, o.PAYMENT_METHOD
    ) AS RESTAURANT_AVG_ORDER_VALUE_BY_PAYMENT,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.FACT_ORDER o
LEFT JOIN GOLD.DIM_CUSTOMER c
    ON o.CUSTOMER_ID = c.CUSTOMER_ID
LEFT JOIN GOLD.DIM_RESTAURANT r
    ON o.RESTAURANT_ID = r.RESTAURANT_ID
LEFT JOIN GOLD.DIM_LOCATION l
    ON r.LOCATION_ID = l.LOCATION_ID
LEFT JOIN GOLD.DIM_DATE d
    ON DATE(o.ORDER_DATE) = d.CALENDAR_DATE;

-- ============================================================================
-- 13. MART_ORDER_RESTAURANT_PERFORMANCE
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_ORDER_RESTAURANT_PERFORMANCE AS
WITH restaurant_order_metrics AS (
    SELECT
        o.RESTAURANT_ID,
        DATE_TRUNC('DAY', o.ORDER_DATE) AS ORDER_DAY,
        DATE_TRUNC('WEEK', o.ORDER_DATE) AS ORDER_WEEK,
        DATE_TRUNC('MONTH', o.ORDER_DATE) AS ORDER_MONTH,
        COUNT(DISTINCT o.ORDER_ID) AS DAILY_ORDERS,
        SUM(o.TOTAL_AMOUNT) AS DAILY_REVENUE,
        AVG(o.TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
        COUNT(DISTINCT o.CUSTOMER_ID) AS UNIQUE_CUSTOMERS,
        SUM(CASE WHEN o.STATUS = 'COMPLETED' THEN 1 ELSE 0 END) AS COMPLETED_ORDERS,
        SUM(CASE WHEN o.STATUS = 'CANCELLED' THEN 1 ELSE 0 END) AS CANCELLED_ORDERS,
        AVG(DATEDIFF(MINUTE, o.CREATED_AT, o.UPDATED_AT)) AS AVG_PROCESSING_TIME
    FROM GOLD.FACT_ORDER o
    WHERE o.STATUS = 'ACTIVE'
    GROUP BY
        o.RESTAURANT_ID,
        DATE_TRUNC('DAY', o.ORDER_DATE),
        DATE_TRUNC('WEEK', o.ORDER_DATE),
        DATE_TRUNC('MONTH', o.ORDER_DATE)
)
SELECT
    rom.RESTAURANT_ID,
    r.RESTAURANT_NAME,
    r.CUISINE_TYPE,
    r.PRICING_FOR_TWO,
    r.LOCALITY,
    l.CITY,
    l.STATE,
    l.CITY_TIER,
    rom.ORDER_DAY,
    rom.ORDER_WEEK,
    rom.ORDER_MONTH,
    rom.DAILY_ORDERS,
    rom.DAILY_REVENUE,
    rom.AVG_ORDER_VALUE,
    rom.UNIQUE_CUSTOMERS,
    rom.COMPLETED_ORDERS,
    rom.CANCELLED_ORDERS,
    rom.AVG_PROCESSING_TIME,
    DIV0(rom.COMPLETED_ORDERS, rom.DAILY_ORDERS) * 100 AS COMPLETION_RATE,
    DIV0(rom.CANCELLED_ORDERS, rom.DAILY_ORDERS) * 100 AS CANCELLATION_RATE,
    DIV0(rom.UNIQUE_CUSTOMERS, rom.DAILY_ORDERS) AS CUSTOMER_REPEAT_RATIO,
    AVG(rom.DAILY_ORDERS) OVER (
        PARTITION BY rom.RESTAURANT_ID
        ORDER BY rom.ORDER_DAY
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS MA7_ORDERS,
    AVG(rom.DAILY_REVENUE) OVER (
        PARTITION BY rom.RESTAURANT_ID
        ORDER BY rom.ORDER_DAY
        ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) AS MA7_REVENUE,
    LAG(rom.DAILY_ORDERS, 7) OVER (
        PARTITION BY rom.RESTAURANT_ID
        ORDER BY rom.ORDER_DAY
    ) AS ORDERS_SAME_DAY_LAST_WEEK,
    DIV0(
        (rom.DAILY_ORDERS - LAG(rom.DAILY_ORDERS, 7) OVER (
            PARTITION BY rom.RESTAURANT_ID
            ORDER BY rom.ORDER_DAY
        )),
        LAG(rom.DAILY_ORDERS, 7) OVER (
            PARTITION BY rom.RESTAURANT_ID
            ORDER BY rom.ORDER_DAY
        )
    ) * 100 AS WOW_ORDER_GROWTH_PCT,
    SUM(rom.DAILY_ORDERS) OVER (
        PARTITION BY rom.RESTAURANT_ID, rom.ORDER_MONTH
        ORDER BY rom.ORDER_DAY
    ) AS MTD_ORDERS,
    SUM(rom.DAILY_REVENUE) OVER (
        PARTITION BY rom.RESTAURANT_ID, rom.ORDER_MONTH
        ORDER BY rom.ORDER_DAY
    ) AS MTD_REVENUE,
    DENSE_RANK() OVER (
        PARTITION BY rom.ORDER_DAY, l.CITY
        ORDER BY rom.DAILY_ORDERS DESC
    ) AS CITY_DAILY_ORDER_RANK,
    DENSE_RANK() OVER (
        PARTITION BY rom.ORDER_DAY, l.CITY
        ORDER BY rom.DAILY_REVENUE DESC
    ) AS CITY_DAILY_REVENUE_RANK,
    CASE
        WHEN rom.DAILY_ORDERS >= 50 AND rom.DAILY_REVENUE >= 25000 THEN 'TOP_PERFORMER'
        WHEN rom.DAILY_ORDERS >= 20 AND rom.DAILY_REVENUE >= 10000 THEN 'HIGH_PERFORMER'
        WHEN rom.DAILY_ORDERS >= 10 THEN 'AVERAGE_PERFORMER'
        ELSE 'LOW_PERFORMER'
    END AS PERFORMANCE_TIER,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM restaurant_order_metrics rom
LEFT JOIN GOLD.DIM_RESTAURANT r
    ON rom.RESTAURANT_ID = r.RESTAURANT_ID
LEFT JOIN GOLD.DIM_LOCATION l
    ON r.LOCATION_ID = l.LOCATION_ID;

-- ============================================================================
-- 14. MART_ORDER_STATUS_ANALYSIS
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_ORDER_STATUS_ANALYSIS AS
WITH order_base AS (
    SELECT
        o.ORDER_ID,
        o.ORDER_DATE,
        o.CUSTOMER_ID,
        o.RESTAURANT_ID,
        o.TOTAL_AMOUNT,
        o.STATUS AS CURRENT_STATUS,
        o.STATUS AS INITIAL_STATUS,
        o.UPDATED_AT AS STATUS_UPDATED_AT,
        o.CREATED_AT,
        r.RESTAURANT_NAME,
        r.CUISINE_TYPE,
        c.CUSTOMER_NAME
    FROM GOLD.FACT_ORDER o
    LEFT JOIN GOLD.DIM_RESTAURANT r
        ON o.RESTAURANT_ID = r.RESTAURANT_ID
    LEFT JOIN GOLD.DIM_CUSTOMER c
        ON o.CUSTOMER_ID = c.CUSTOMER_ID
    WHERE o.STATUS = 'ACTIVE'
),
status_transitions AS (
    SELECT
        osh.ORDER_ID,
        osh.OLD_STATUS,
        osh.NEW_STATUS,
        osh.STATUS_CHANGED_AT,
        LAG(osh.STATUS_CHANGED_AT) OVER (
            PARTITION BY osh.ORDER_ID
            ORDER BY osh.STATUS_CHANGED_AT
        ) AS PREVIOUS_STATUS_TIME,
        ROW_NUMBER() OVER (
            PARTITION BY osh.ORDER_ID
            ORDER BY osh.STATUS_CHANGED_AT
        ) AS STATUS_SEQUENCE_NUMBER,
        COUNT(*) OVER (
            PARTITION BY osh.ORDER_ID
        ) AS TOTAL_STATUS_CHANGES
    FROM GOLD.FACT_ORDER_STATUS_HISTORY osh
),
status_durations AS (
    SELECT
        ORDER_ID,
        OLD_STATUS,
        NEW_STATUS,
        STATUS_CHANGED_AT,
        STATUS_SEQUENCE_NUMBER,
        TOTAL_STATUS_CHANGES,
        DATEDIFF(
            MINUTE,
            PREVIOUS_STATUS_TIME,
            STATUS_CHANGED_AT
        ) AS MINUTES_IN_PREVIOUS_STATUS
    FROM status_transitions
)
SELECT
    ob.ORDER_ID,
    ob.ORDER_DATE,
    ob.CUSTOMER_ID,
    ob.CUSTOMER_NAME,
    ob.RESTAURANT_ID,
    ob.RESTAURANT_NAME,
    ob.CUISINE_TYPE,
    ob.TOTAL_AMOUNT,
    ob.CURRENT_STATUS,
    ob.INITIAL_STATUS,
    ob.STATUS_UPDATED_AT,
    MAX(sd.TOTAL_STATUS_CHANGES) AS TOTAL_STATUS_CHANGES,
    SUM(CASE WHEN sd.OLD_STATUS = 'PENDING'
        THEN sd.MINUTES_IN_PREVIOUS_STATUS ELSE 0 END) AS MINUTES_IN_PENDING,
    SUM(CASE WHEN sd.OLD_STATUS = 'CONFIRMED'
        THEN sd.MINUTES_IN_PREVIOUS_STATUS ELSE 0 END) AS MINUTES_IN_CONFIRMED,
    SUM(CASE WHEN sd.OLD_STATUS = 'PREPARING'
        THEN sd.MINUTES_IN_PREVIOUS_STATUS ELSE 0 END) AS MINUTES_IN_PREPARING,
    SUM(CASE WHEN sd.OLD_STATUS = 'READY'
        THEN sd.MINUTES_IN_PREVIOUS_STATUS ELSE 0 END) AS MINUTES_IN_READY,
    SUM(CASE WHEN sd.OLD_STATUS = 'OUT_FOR_DELIVERY'
        THEN sd.MINUTES_IN_PREVIOUS_STATUS ELSE 0 END) AS MINUTES_IN_OUT_FOR_DELIVERY,
    DATEDIFF(MINUTE, ob.CREATED_AT, ob.STATUS_UPDATED_AT) AS TOTAL_PROCESSING_TIME_MINS,
    MIN(sd.STATUS_CHANGED_AT) AS FIRST_STATUS_CHANGE_TIME,
    DATEDIFF(MINUTE, ob.CREATED_AT, MIN(sd.STATUS_CHANGED_AT)) AS MINUTES_TO_FIRST_STATUS_CHANGE,
    CASE
        WHEN MAX(sd.TOTAL_STATUS_CHANGES) >= 5 THEN 'HIGH_VELOCITY'
        WHEN MAX(sd.TOTAL_STATUS_CHANGES) >= 3 THEN 'NORMAL_VELOCITY'
        ELSE 'LOW_VELOCITY'
    END AS STATUS_CHANGE_VELOCITY,
    CASE
        WHEN ob.CURRENT_STATUS = 'CANCELLED'
            AND MAX(sd.STATUS_SEQUENCE_NUMBER) = 1 THEN 'CANCELLED_IMMEDIATELY'
        WHEN ob.CURRENT_STATUS = 'CANCELLED'
            AND MAX(sd.STATUS_SEQUENCE_NUMBER) <= 3 THEN 'CANCELLED_EARLY'
        WHEN ob.CURRENT_STATUS = 'CANCELLED' THEN 'CANCELLED_LATE'
        ELSE 'NOT_CANCELLED'
    END AS CANCELLATION_STAGE,
    CASE
        WHEN ob.CURRENT_STATUS = 'COMPLETED'
            AND DATEDIFF(MINUTE, ob.CREATED_AT, ob.STATUS_UPDATED_AT) <= 60
        THEN 'FAST_COMPLETION'
        WHEN ob.CURRENT_STATUS = 'COMPLETED' THEN 'NORMAL_COMPLETION'
        WHEN ob.CURRENT_STATUS = 'CANCELLED' THEN 'FAILED'
        ELSE 'IN_PROGRESS'
    END AS ORDER_OUTCOME,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM order_base ob
LEFT JOIN status_durations sd
    ON ob.ORDER_ID = sd.ORDER_ID
GROUP BY
    ob.ORDER_ID, ob.ORDER_DATE, ob.CUSTOMER_ID, ob.CUSTOMER_NAME,
    ob.RESTAURANT_ID, ob.RESTAURANT_NAME, ob.CUISINE_TYPE, ob.TOTAL_AMOUNT,
    ob.CURRENT_STATUS, ob.INITIAL_STATUS, ob.STATUS_UPDATED_AT, ob.CREATED_AT;

-- ============================================================================
-- 15. MART_ORDER_SUMMARY
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_ORDER_SUMMARY AS
SELECT
    o.ORDER_ID,
    o.ORDER_DATE,
    DATE(o.ORDER_DATE) AS ORDER_DATE_KEY,
    o.TOTAL_AMOUNT,
    o.STATUS AS CURRENT_STATUS,
    o.STATUS AS INITIAL_STATUS,
    o.PAYMENT_METHOD,
    o.UPDATED_AT AS STATUS_UPDATED_AT,
    o.CUSTOMER_ID,
    c.CUSTOMER_NAME,
    c.GENDER AS CUSTOMER_GENDER,
    c.LOGIN_BY_USING,
    DATEDIFF(YEAR, c.DOB, o.ORDER_DATE) AS CUSTOMER_AGE_AT_ORDER,
    o.RESTAURANT_ID,
    r.RESTAURANT_NAME,
    r.CUISINE_TYPE,
    r.PRICING_FOR_TWO AS RESTAURANT_PRICING,
    r.LOCALITY AS RESTAURANT_LOCALITY,
    l.CITY,
    l.STATE,
    l.CITY_TIER,
    l.ZIP_CODE,
    fd.DELIVERY_ID,
    fd.DELIVERY_AGENT_ID,
    fd.DELIVERY_DATE,
    fd.STATUS AS DELIVERY_STATUS,
    TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER) AS ESTIMATED_DELIVERY_TIME_MINS,
    DATEDIFF(MINUTE, o.ORDER_DATE, fd.DELIVERY_DATE) AS ACTUAL_DELIVERY_TIME_MINS,
    d.YEAR,
    d.QUARTER,
    d.MONTH,
    d.WEEK,
    d.DAY_OF_WEEK,
    d.DAY_NAME,
    HOUR(o.ORDER_DATE) AS ORDER_HOUR,
    CASE
        WHEN HOUR(o.ORDER_DATE) BETWEEN 6 AND 11 THEN 'MORNING'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 12 AND 16 THEN 'AFTERNOON'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 17 AND 21 THEN 'EVENING'
        ELSE 'NIGHT'
    END AS TIME_OF_DAY,
    CASE
        WHEN d.DAY_OF_WEEK IN (6, 7) THEN 'WEEKEND'
        ELSE 'WEEKDAY'
    END AS DAY_TYPE,
    CASE
        WHEN o.TOTAL_AMOUNT < 200 THEN 'LOW_VALUE'
        WHEN o.TOTAL_AMOUNT < 500 THEN 'MEDIUM_VALUE'
        WHEN o.TOTAL_AMOUNT < 1000 THEN 'HIGH_VALUE'
        ELSE 'PREMIUM'
    END AS ORDER_VALUE_SEGMENT,
    ROW_NUMBER() OVER (
        PARTITION BY o.CUSTOMER_ID
        ORDER BY o.ORDER_DATE
    ) AS CUSTOMER_ORDER_NUMBER,
    ROW_NUMBER() OVER (
        PARTITION BY o.RESTAURANT_ID
        ORDER BY o.ORDER_DATE
    ) AS RESTAURANT_ORDER_NUMBER,
    CASE WHEN o.STATUS = 'COMPLETED' THEN 1 ELSE 0 END AS IS_COMPLETED,
    CASE WHEN o.STATUS = 'CANCELLED' THEN 1 ELSE 0 END AS IS_CANCELLED,
    CASE WHEN o.STATUS = 'PENDING' THEN 1 ELSE 0 END AS IS_PENDING,
    CASE
        WHEN fd.STATUS = 'DELIVERED'
            AND DATEDIFF(MINUTE, o.ORDER_DATE, fd.DELIVERY_DATE) <=
                TRY_CAST(REGEXP_REPLACE(fd.ESTIMATED_TIME, '[^0-9]', '') AS INTEGER)
        THEN 1
        ELSE 0
    END AS IS_ON_TIME_DELIVERY,
    CASE
        WHEN fd.STATUS = 'DELIVERED' THEN 1
        ELSE 0
    END AS IS_DELIVERED,
    DATEDIFF(MINUTE, o.CREATED_AT, o.UPDATED_AT) AS ORDER_PROCESSING_TIME_MINS,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.FACT_ORDER o
LEFT JOIN GOLD.DIM_CUSTOMER c
    ON o.CUSTOMER_ID = c.CUSTOMER_ID
LEFT JOIN GOLD.DIM_RESTAURANT r
    ON o.RESTAURANT_ID = r.RESTAURANT_ID
LEFT JOIN GOLD.DIM_LOCATION l
    ON r.LOCATION_ID = l.LOCATION_ID
LEFT JOIN GOLD.FACT_DELIVERY fd
    ON o.ORDER_ID = fd.ORDER_ID
LEFT JOIN GOLD.DIM_DATE d
    ON DATE(o.ORDER_DATE) = d.CALENDAR_DATE
WHERE o.STATUS = 'ACTIVE';

-- ============================================================================
-- 16. MART_ORDER_TIME_ANALYSIS
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_ORDER_TIME_ANALYSIS AS
SELECT
    o.ORDER_ID,
    o.ORDER_DATE,
    DATE(o.ORDER_DATE) AS ORDER_DATE_KEY,
    o.CUSTOMER_ID,
    o.RESTAURANT_ID,
    o.TOTAL_AMOUNT,
    o.STATUS AS CURRENT_STATUS,
    o.PAYMENT_METHOD,
    d.YEAR,
    d.QUARTER,
    d.MONTH,
    d.WEEK,
    d.DAY_OF_YEAR,
    d.DAY_OF_WEEK,
    d.DAY_OF_THE_MONTH,
    d.DAY_NAME,
    HOUR(o.ORDER_DATE) AS ORDER_HOUR,
    MINUTE(o.ORDER_DATE) AS ORDER_MINUTE,
    CASE
        WHEN HOUR(o.ORDER_DATE) BETWEEN 6 AND 11 THEN 'MORNING'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 12 AND 16 THEN 'AFTERNOON'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 17 AND 21 THEN 'EVENING'
        ELSE 'NIGHT'
    END AS TIME_OF_DAY,
    CASE
        WHEN d.DAY_OF_WEEK IN (6, 7) THEN 'WEEKEND'
        ELSE 'WEEKDAY'
    END AS DAY_TYPE,
    CASE
        WHEN d.DAY_OF_WEEK = 1 THEN 'MONDAY'
        WHEN d.DAY_OF_WEEK = 5 THEN 'FRIDAY'
        WHEN d.DAY_OF_WEEK IN (6, 7) THEN 'WEEKEND'
        ELSE 'MID_WEEK'
    END AS DAY_CATEGORY,
    CASE
        WHEN HOUR(o.ORDER_DATE) BETWEEN 7 AND 10 THEN 'BREAKFAST'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 11 AND 14 THEN 'LUNCH'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 16 AND 18 THEN 'SNACK'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 19 AND 22 THEN 'DINNER'
        ELSE 'LATE_NIGHT'
    END AS MEAL_TIME,
    CASE
        WHEN HOUR(o.ORDER_DATE) BETWEEN 12 AND 14 THEN 'LUNCH_PEAK'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 19 AND 21 THEN 'DINNER_PEAK'
        ELSE 'OFF_PEAK'
    END AS PEAK_INDICATOR,
    r.RESTAURANT_NAME,
    r.CUISINE_TYPE,
    l.CITY,
    l.STATE,
    COUNT(o.ORDER_ID) OVER (
        PARTITION BY DATE(o.ORDER_DATE), HOUR(o.ORDER_DATE)
    ) AS ORDERS_IN_SAME_HOUR,
    COUNT(o.ORDER_ID) OVER (
        PARTITION BY o.RESTAURANT_ID, DATE(o.ORDER_DATE), HOUR(o.ORDER_DATE)
    ) AS RESTAURANT_ORDERS_IN_SAME_HOUR,
    COUNT(o.ORDER_ID) OVER (
        PARTITION BY o.CUSTOMER_ID, DATE(o.ORDER_DATE)
    ) AS CUSTOMER_ORDERS_SAME_DAY,
    AVG(o.TOTAL_AMOUNT) OVER (
        PARTITION BY HOUR(o.ORDER_DATE)
    ) AS AVG_ORDER_VALUE_FOR_HOUR,
    AVG(o.TOTAL_AMOUNT) OVER (
        PARTITION BY d.DAY_OF_WEEK
    ) AS AVG_ORDER_VALUE_FOR_DAY,
    CASE
        WHEN d.MONTH IN (12, 1, 2) THEN 'WINTER'
        WHEN d.MONTH IN (3, 4, 5) THEN 'SPRING'
        WHEN d.MONTH IN (6, 7, 8) THEN 'SUMMER'
        ELSE 'FALL'
    END AS SEASON,
    CASE
        WHEN d.DAY_OF_THE_MONTH <= 10 THEN 'EARLY_MONTH'
        WHEN d.DAY_OF_THE_MONTH <= 20 THEN 'MID_MONTH'
        ELSE 'END_MONTH'
    END AS MONTH_PERIOD,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.FACT_ORDER o
LEFT JOIN GOLD.DIM_DATE d
    ON DATE(o.ORDER_DATE) = d.CALENDAR_DATE
LEFT JOIN GOLD.DIM_RESTAURANT r
    ON o.RESTAURANT_ID = r.RESTAURANT_ID
LEFT JOIN GOLD.DIM_LOCATION l
    ON r.LOCATION_ID = l.LOCATION_ID
WHERE o.STATUS = 'ACTIVE';

-- ============================================================================
-- 17. MART_CUISINE_PERFORMANCE
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_CUISINE_PERFORMANCE AS
SELECT
    r.CUISINE_TYPE,
    l.CITY,
    l.STATE,
    l.CITY_TIER,
    COUNT(DISTINCT r.RESTAURANT_ID) AS RESTAURANT_COUNT,
    COUNT(DISTINCT o.ORDER_ID) AS TOTAL_ORDERS,
    SUM(o.TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(o.TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    DIV0(COUNT(DISTINCT o.ORDER_ID),
         COUNT(DISTINCT r.RESTAURANT_ID)) AS AVG_ORDERS_PER_RESTAURANT,
    DIV0(SUM(o.TOTAL_AMOUNT),
         COUNT(DISTINCT r.RESTAURANT_ID)) AS AVG_REVENUE_PER_RESTAURANT,
    COUNT(DISTINCT o.CUSTOMER_ID) AS UNIQUE_CUSTOMERS,
    AVG(r.PRICING_FOR_TWO) AS AVG_PRICING_FOR_TWO,
    DIV0(SUM(o.TOTAL_AMOUNT),
         SUM(SUM(o.TOTAL_AMOUNT)) OVER (PARTITION BY l.CITY)) * 100 AS CITY_MARKET_SHARE_PCT,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.DIM_RESTAURANT r
LEFT JOIN GOLD.FACT_ORDER o
    ON r.RESTAURANT_ID = o.RESTAURANT_ID
    AND o.STATUS = 'ACTIVE'
LEFT JOIN GOLD.DIM_LOCATION l
    ON r.LOCATION_ID = l.LOCATION_ID
WHERE r.STATUS = 'ACTIVE'
GROUP BY r.CUISINE_TYPE, l.CITY, l.STATE, l.CITY_TIER;

-- ============================================================================
-- 18. MART_RESTAURANT_MENU_PERFORMANCE
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_RESTAURANT_MENU_PERFORMANCE AS
WITH menu_orders AS (
    SELECT
        m.MENU_ID,
        m.RESTAURANT_ID,
        m.ITEM_NAME,
        m.CATEGORY,
        m.PRICE,
        m.ITEM_TYPE,
        m.AVAILABILITY,
        COUNT(DISTINCT o.ORDER_ID) AS ESTIMATED_ORDERS,
        DIV0(SUM(o.TOTAL_AMOUNT),
             NULLIF(COUNT(DISTINCT o.ORDER_ID), 0)) AS AVG_ORDER_WITH_ITEM
    FROM GOLD.DIM_MENU m
    LEFT JOIN GOLD.FACT_ORDER o
        ON m.RESTAURANT_ID = o.RESTAURANT_ID
        AND o.STATUS = 'ACTIVE'
    WHERE m.STATUS = 'ACTIVE'
    GROUP BY
        m.MENU_ID, m.RESTAURANT_ID, m.ITEM_NAME,
        m.CATEGORY, m.PRICE, m.ITEM_TYPE, m.AVAILABILITY
)
SELECT
    mo.MENU_ID,
    mo.RESTAURANT_ID,
    r.RESTAURANT_NAME,
    mo.ITEM_NAME,
    mo.CATEGORY,
    mo.PRICE,
    mo.ITEM_TYPE,
    mo.AVAILABILITY,
    mo.ESTIMATED_ORDERS,
    mo.AVG_ORDER_WITH_ITEM,
    AVG(mo.PRICE) OVER (
        PARTITION BY mo.RESTAURANT_ID, mo.CATEGORY
    ) AS AVG_CATEGORY_PRICE,
    DIV0(mo.PRICE,
         NULLIF(AVG(mo.PRICE) OVER (
             PARTITION BY mo.RESTAURANT_ID, mo.CATEGORY
         ), 0)) * 100 AS PRICE_INDEX,
    ROW_NUMBER() OVER (
        PARTITION BY mo.RESTAURANT_ID
        ORDER BY mo.ESTIMATED_ORDERS DESC
    ) AS POPULARITY_RANK,
    ROW_NUMBER() OVER (
        PARTITION BY mo.RESTAURANT_ID
        ORDER BY (mo.PRICE * mo.ESTIMATED_ORDERS) DESC
    ) AS REVENUE_RANK,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM menu_orders mo
LEFT JOIN GOLD.DIM_RESTAURANT r
    ON mo.RESTAURANT_ID = r.RESTAURANT_ID;

-- ============================================================================
-- 19. MART_RESTAURANT_PERFORMANCE
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_RESTAURANT_PERFORMANCE AS
SELECT
    r.RESTAURANT_ID,
    r.RESTAURANT_NAME,
    r.CUISINE_TYPE,
    r.PRICING_FOR_TWO,
    r.LOCALITY,
    l.CITY,
    l.STATE,
    l.CITY_TIER,
    r.OPEN_STATUS,
    COUNT(DISTINCT o.ORDER_ID) AS TOTAL_ORDERS,
    COUNT(DISTINCT o.CUSTOMER_ID) AS UNIQUE_CUSTOMERS,
    SUM(o.TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(o.TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    DIV0(COUNT(DISTINCT o.ORDER_ID),
         COUNT(DISTINCT o.CUSTOMER_ID)) AS ORDERS_PER_CUSTOMER,
    SUM(CASE WHEN o.STATUS = 'COMPLETED' THEN 1 ELSE 0 END) AS COMPLETED_ORDERS,
    SUM(CASE WHEN o.STATUS = 'CANCELLED' THEN 1 ELSE 0 END) AS CANCELLED_ORDERS,
    DIV0(SUM(CASE WHEN o.STATUS = 'CANCELLED' THEN 1 ELSE 0 END),
         COUNT(*)) * 100 AS CANCELLATION_RATE,
    MIN(o.ORDER_DATE) AS FIRST_ORDER_DATE,
    MAX(o.ORDER_DATE) AS LAST_ORDER_DATE,
    DATEDIFF(DAY, MIN(o.ORDER_DATE), MAX(o.ORDER_DATE)) AS OPERATIONAL_DAYS,
    DIV0(COUNT(DISTINCT o.ORDER_ID),
         NULLIF(COUNT(DISTINCT DATE(o.ORDER_DATE)), 0)) AS AVG_ORDERS_PER_DAY,
    DIV0(SUM(o.TOTAL_AMOUNT),
         NULLIF(COUNT(DISTINCT DATE(o.ORDER_DATE)), 0)) AS AVG_REVENUE_PER_DAY,
    CASE
        WHEN COUNT(DISTINCT o.ORDER_ID) >= 500 AND AVG(o.TOTAL_AMOUNT) >= 500 THEN 'PLATINUM'
        WHEN COUNT(DISTINCT o.ORDER_ID) >= 200 AND AVG(o.TOTAL_AMOUNT) >= 300 THEN 'GOLD'
        WHEN COUNT(DISTINCT o.ORDER_ID) >= 50 THEN 'SILVER'
        ELSE 'BRONZE'
    END AS RESTAURANT_TIER,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.DIM_RESTAURANT r
LEFT JOIN GOLD.FACT_ORDER o
    ON r.RESTAURANT_ID = o.RESTAURANT_ID
    AND o.STATUS = 'ACTIVE'
LEFT JOIN GOLD.DIM_LOCATION l
    ON r.LOCATION_ID = l.LOCATION_ID
WHERE r.STATUS = 'ACTIVE'
GROUP BY
    r.RESTAURANT_ID, r.RESTAURANT_NAME, r.CUISINE_TYPE, r.PRICING_FOR_TWO,
    r.LOCALITY, l.CITY, l.STATE, l.CITY_TIER, r.OPEN_STATUS;

-- ============================================================================
-- 20. MART_RESTAURANT_TIME_PERFORMANCE
-- ============================================================================
CREATE OR REPLACE VIEW ANALYTICS.MART_RESTAURANT_TIME_PERFORMANCE AS
SELECT
    r.RESTAURANT_ID,
    r.RESTAURANT_NAME,
    r.CUISINE_TYPE,
    d.DAY_NAME,
    d.DAY_OF_WEEK,
    CASE
        WHEN d.DAY_OF_WEEK IN (6, 7) THEN 'WEEKEND'
        ELSE 'WEEKDAY'
    END AS DAY_TYPE,
    HOUR(o.ORDER_DATE) AS ORDER_HOUR,
    CASE
        WHEN HOUR(o.ORDER_DATE) BETWEEN 6 AND 11 THEN 'MORNING'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 12 AND 16 THEN 'AFTERNOON'
        WHEN HOUR(o.ORDER_DATE) BETWEEN 17 AND 21 THEN 'EVENING'
        ELSE 'NIGHT'
    END AS TIME_OF_DAY,
    COUNT(DISTINCT o.ORDER_ID) AS TOTAL_ORDERS,
    SUM(o.TOTAL_AMOUNT) AS TOTAL_REVENUE,
    AVG(o.TOTAL_AMOUNT) AS AVG_ORDER_VALUE,
    COUNT(DISTINCT o.CUSTOMER_ID) AS UNIQUE_CUSTOMERS,
    SUM(CASE WHEN o.STATUS = 'COMPLETED' THEN 1 ELSE 0 END) AS COMPLETED_ORDERS,
    DIV0(SUM(CASE WHEN o.STATUS = 'COMPLETED' THEN 1 ELSE 0 END),
         COUNT(*)) * 100 AS COMPLETION_RATE,
    ROW_NUMBER() OVER (
        PARTITION BY r.RESTAURANT_ID
        ORDER BY COUNT(DISTINCT o.ORDER_ID) DESC
    ) AS PEAK_TIME_RANK,
    CURRENT_TIMESTAMP() AS CREATED_AT
FROM GOLD.DIM_RESTAURANT r
INNER JOIN GOLD.FACT_ORDER o
    ON r.RESTAURANT_ID = o.RESTAURANT_ID
    AND o.STATUS = 'ACTIVE'
LEFT JOIN GOLD.DIM_DATE d
    ON DATE(o.ORDER_DATE) = d.CALENDAR_DATE
WHERE r.STATUS = 'ACTIVE'
GROUP BY
    r.RESTAURANT_ID, r.RESTAURANT_NAME, r.CUISINE_TYPE,
    d.DAY_NAME, d.DAY_OF_WEEK, DAY_TYPE, ORDER_HOUR, TIME_OF_DAY;